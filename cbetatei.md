# 轉換 CBETA TEI 

## 步驟
1. 化空 (Nullify)    將包夾文字的標籤化為空標籤。
2. 剝籤 (Peel Tag)   將底文從XML文件剝離出來。
3. 切塊 (Chunkify)   將底文分成小塊，並賦於穩定的代號。
4. 入庫 (Pitaka)     加入必要的結構標籤，轉成 pitaka 數據庫。
5. 分層 (layering)   以`文釘`將標籤外部化，即`文層`化。

## 1.化空
化空將choice/app/cb:tt/note 等標記化為空標籤，即將包夾的內文，移入為屬性值，以釐清底文和標籤的角色。
```xml
<app n="0567004"><lem wit="【大】">宛</lem><rdg resp="Taisho" wit="【聖】">婉</rdg></app>轉四流、甘履八苦
```
純文字會變成 `宛婉轉四流、甘履八苦`，從閱讀者角度這並不正確。而空化後的標籤：
```xml
<app n="0567004"><lem wit="【大】">宛</lem><t_rdg t="婉" wit="【聖】"/></app>轉四流、甘履八苦
```
純文字會變成 `宛轉四流、甘履八苦`。resp="Taisho" 簡化為 t_rdg 標籤，減少冗餘。

空化之後的 XML，不再遵循TEI標準。但兩者等價，很容易轉回原來的格式 。

## 2.剝籤
將 XML 分為純文字及標籤陣列。剝剖後的標籤只是陣列，很容易進行增刪、合併及比較，遠比直接操作「樹」簡潔高效。
```xml
<app n="0567004"><lem wit="【大】">宛</lem><t_rdg t="婉" wit="【聖】"/></app>轉四流、甘履八苦
```
文件剝除標籤，產生純文字 `宛轉四流、甘履八苦` 以及標籤陣列，
結構為 開合, 序號，標籤名，字距, 屬性。
\+ 為開, - 為合，空白為空標籤，序號表示同名第幾個 ， 字距為與上一個出現標籤差幾個字。
```
+	4	app	    0	{"n":"0567004"}
+	4	lem 	0	{"wit":"【大】"}
-	4	lem 	1
	4	t_rdg	0	{"t":"婉","wit":"【聖】"}
-	4	app	    0
```
1548 指到`宛`， 17表示< app> , -17 表示 </ app>，18 表示< lem> , -18 表示 </ lem> ，
19 和 -19 的位址都是 1549 ，因此是一個不包夾底文的空標籤。

## 3.切塊
由於字元位址依賴於底文，對人類也不直觀，必須轉換為文釘，以穩定標籤位置。
為了文釘的高效，底文必須依「內容」切分成`文塊`，並賦於穩定的代號。
文塊同時也是閱讀單元，故前後相關的文字，應在同一塊。

文塊大約是一般意義上的「小節」、「短篇」。文塊不宜過大，大小越均勻越好。

文塊的賦碼有兩種方式，一是從 目錄自動產生，即利用CBETA TEI 中的 cb:div , cb:mulu 資訊。
另一種是人工分塊，即用「冊頁欄行字」標定文塊。

## 4.改版
由於底文不方便程序處理，故需補入必要的結構標記（ak, bk, ck )，產生ptk數據庫的源文件 (.off) 。

## 5.釘址
改版後，將非必要的標籤皆外部化，即以文釘定址，例如：四分律序 的文塊代碼為`xu`。 

則有 `xu:夫` 代表第一段`夫戒之興，所以防邪檢失` 的起點。
並有一個校勘 `xu:宛` 有一個校勘`婉【聖】`

定址後的校勘，自然就形成了「大正藏校勘文層」，而從底文剝離。
由於各個文層在不同的儲存空間，有兩個好處：

一）經文逃離大正株式會社的版權桎梏，回歸到自古以來的公共財產。

二）對底文的標注和加工，可以享有著作權以及延伸權利，掃除了進入市場的障礙。


## 其他

### 拆解一般XML 標籤
ptk xmltag 文件或目錄 輸出目錄

目錄支持 ? 及半形方括語法(正則)。每一個xml 都會輸出兩個文件，底文（.txt）和 標記(.tsv)。

缺少輸出目錄則不產生轉換結果。輸入多於一個文件，會產生 elements-count.json , elements-child.json 

elements-count.json 列出標記名及頻次，elements-child.json 列出巢狀標籤的子代。以下這兩行表示 bibl 包了 title ，而 title 又包了 lb, note ... 。

    bibl	title
    title	lb,note,app,anchor
